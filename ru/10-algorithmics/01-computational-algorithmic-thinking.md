---
title: Вычислительное/алгоритмическое мышление
---

Вычислительное мышление/computational thinking/алгоритмическое
мышление/информатика --- это мышление с использованием набора понятий
computer science (вычисление, алгоритм, ...), примерно так же как
«физическое мышление» связано с физикой-наукой (физическое тело, поле,
...) или химическое мышление связано с химией-наукой и её набором
понятий (химическая связь, валентность, ...), или даже системное
мышление связано с набором понятий системного подхода (система,
эмерджентность, ...).

Термин информатика/computational thinking появился в середине 80х, когда
computer science потребовалось внести в школьные программы (в США и СССР
это было одновременно --- в США назвали computational thinking, в
СССР --- информатика), для обсуждения с организаторами образования нужно
было делать акцент не на содержании предмета, а на навыках мышления,
которые даёт знание нового школьного предмета. Тогда вычислительное
мышление/информатика понималось прежде всего как навыки планирования
каких-то действий, возможно с условиями. То есть идеи active/embodied
inference (неразрывность действий в мире и вычислений, физической
природы последовательности операций) были в идее вычислительного
мышления с самого начала. В то время для школ предлагалось изучать
только императивную алгоритмику (классическое структурное
программирование, а не пакетное программирование как в Modula и Ada,
объект-ориентированное программирование, функциональное
программирование, логическое программирование), и это не изменилось за
последние почти 40 лет с момента введения обязательного обучения
информатике в школах России в 1985 году (за рубежом обязательное
обучение информатике в школах вводили примерно в тот же период времени).

-   С годами акцент сдвигался с императивной алгоритмики на другие виды
    вычислений/исполнений/execution, логического
    вывода/рассуждений/inference/обновлений, функциональной
    оценки/evaluation и далее вплоть до собственно мышления/cognition
    как проводимого алгоритмом-интеллектом. Сегодня вычислительное
    мышление стало по факту общим мышлением об операциях с моделями ---
    вычисляемом/алгоритмическом преобразовании одних моделей в другие,
    выводе/рассуждениях на базе моделей, моделировании в части разбиения
    на уровни абстракции в моделировании и т.д. Этот классический подход
    мы назовём Software 1.0.
-   Следующий сдвиг объявил Andrei Karpathy как Software 2.0 (программы
    будут не кодироваться, а «выучиваться» на данных с использованием
    различных методов оптимизации для нахождения оптимального алгоритма,
    например каких-нибудь методов оптимизации на основе стохастического
    градиентного спуска): «Gradient descent can write code better than
    you. I'm
    sorry»^[<https://medium.com/@karpathy/software-2-0-a64152b37c35>],
    это 2017 год. Ещё этот подход называется дифференцируемым
    программированием/differentiable programming и далее от
    «программирования» можно переходить к самым разным дифференцируемым
    моделям, получая дифференцируемое моделирование/differentiable
    modeling^[<https://ailev.livejournal.com/1464563.html>,
    <https://fluxml.ai/2019/03/05/dp-vs-rl.html>] --- это
    рассматривается как мощная новая парадигма программирования и
    моделирования (вплоть до архитектурного моделирования, когда на
    архитектуре, представленной непрерывной/недискретной функцией в
    многомерном пространстве, находится оптимум). Похоже, что в
    ближайшем будущем писать программы будут уже не люди, а компьютеры.
-   В 2023 году он уточнил, как будут программировать люди: на
    естественном языке, «The hottest new programming language is
    English»^[<https://twitter.com/karpathy/status/1617979122625712128>],
    и чуть дальше в этом треде: «It\'s still early days but this new
    programming paradigm has the potential to expand the number of
    programmers to \~1.5B
    people»^[<https://twitter.com/karpathy/status/1627366429489266689>],
    что далее было обобщено как Software 3.0, основанное на больших
    языковых моделях.

Тем самым проблема вычислительного мышления далеко выходит за пределы
«программистского мышления, нужного для написания алгоритмов на языке
программирования», речь идёт о массовом мышлении людей, описывающих
алгоритмы как паттерны вычислений, язык и уровень формализации при этом
неважен: программный код или код модели (с прилагающейся к этой модели
интерпретатором, «имитационное моделирование», при этом считаем
программирование как software engineering, моделирование как
simulations, онтологизирование  --- одним и тем же), псевдокод, который
«не программный код в том смысле, что компьютер его не поймёт, но люди
воспринимают его как запись алгоритма», естественный язык, описывающий
постановку задачи по созданию и выполнению алгоритма и идеи по решению
этой задачи.

У каждой модели (как имитационной модели на каком-то языке
программирования, так и каких-нибудь диаграмм) есть её физический
интерпретатор: это или мозг человека, или компьютер, или даже группа
мозгов и компьютеров, в том числе туда могут входить и какие-то другие
инструменты, меняющие как-то мир, они могут включать в вычисление
огромный кусок физического мира. Как думать про этот интерпретатор
модели, описывать его работу, задавать его вычисление, готовить модели
для вычисления на нём --- это и есть вычислительное мышление, предмет
информатики/алгоритмики. Сегодняшнее мышление, особенно коллективное
мышление, редко обходится без участия компьютера. Сегодняшние модели всё
чаще и чаще формальны, они не являются интуитивными художественными
описаниями в виде коротких историй, понятных быстрому мышлению S1,
удобному для нейронной сети человеческого мозга. Они объёмны и требуют
для работы с ними компьютерной поддержки со стороны классических
электронных компьютеров, работающих в парадигме императивного
программирования.

Демифологизация вычислений (включая понимание, что «языки
программирования» для вычислений не главное), понимание того, как они
устроены --- это становится важным для миллиардов людей. Не все станут
программистами, но миллиарды людей. Не все будут профессионалами в
настройке машинного интеллекта, как не все будут профессионалами в
настройке человеческого интеллекта (не все учат других людей, не все
учат искусственные нейронные сетки, но все по факту уже общаются с ними,
а часть таки учит, использует характеристику вменяемости естественного и
искусственного интеллекта: иногда задействует объяснения, а иногда и
просто вырабатывает условный рефлекс, как с кошечками).

Но понимать, как устроена компьютерная часть цивилизации (включая
вычисления, проходящие в живых системах: иммунной системе, мозге, а то и
просто в живой клетке), нужно. Булки не на деревьях растут, вычисления
не на калькуляторах проводятся, в сегодняшних колл-центрах не люди
отвечают, и даже не записанные на автоответчик люди. Демифологизация
всего этого (подготовка хороших и понятных объяснений), компактификация
мышления по поводу вычислений живых и неживых вычислителей/computers
(думать о них нужно одинаково!) быстро меняют современную алгоритмику.

Вычислительное мышление/алгоритмику мы будем отличать от «компьютерной
грамотности»: умению включать-выключать компьютер или смартфон, умению
составить запрос к поисковой системе, умению вызвать приложение для
заказа продуктов в онлайн-универмаге. И будем отличать от риторики как
части лидерства: как уговорить какого-то человека выполнить какой-то
деятельностный алгоритм (паттерн операций над какими-то объектами
мышления и действия). Интересует дисциплина как набор понятий и
отношений между ними (или в конструктивной онтологии набор понятий и
операций над ними), а не конкретные особенности инженерной реализации
поддержки трансдисциплины в мире.

Вычислительное мышление как алгоритмика тем самым находится в ряду
других мыслительных/фундаментальных трансдисциплин: до сих пор в
интеллект-стеке мы рассматривали дисциплины, которые дают нам модели
окружающего мира, а теперь будем рассматривать операции с этими
моделями. При этом помним, что сама алгоритмика (учение об алгоритмах)
может путаться с computer science и информатикой, понимаемой более
широко как включающей в себя семантику и теорию понятий: выполнение
каких-то паттернов/шаблонов операций (то есть выполнение вычислений
согласно алгоритмам) связано с операндами, которые представляют собой
типизированные данные. И когда мы обсуждаем значение этих данных, то
неминуемо всплывает в полном объёме вся семантика и теория понятий, а
поскольку в интеллект-стеке мы отдельно уже разбирались с семантикой и
теорией понятий, то мы тут в разделе алгоритмики интеллект-стека больше
касаться будем не столько всей «компьютерной науки»/информатики в целом,
как включающей и часть про алгоритмы, и часть про данные (Niclaus Wirth
говорил ещё в 1976 году, «Algorithms + Data Structures = Programs» и
даже написал про это
книгу^[<https://en.wikipedia.org/wiki/Algorithms_%2B_Data_Structures_%3D_Programs>]),
сколько только её части про алгоритмы.
